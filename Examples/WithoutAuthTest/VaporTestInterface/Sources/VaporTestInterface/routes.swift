import Vapor
import Authentication

// routes.swift
//
// Generated by SwiftVapor3 swagger-codegen
// https://github.com/swagger-api/swagger-codegen
// Template Input: 

private class SwaggerPath: PathComponentsRepresentable {
  private var path: String

  fileprivate init(path: String) {
    self.path = path
  }

  public func convertToPathComponents() -> [PathComponent] {
    return path.split(separator: "/").map {
      if $0.starts(with: "{") && $0.hasSuffix("}") {
        return PathComponent.parameter("string")
      } else {
        return PathComponent.constant(.init($0))
      }
    }
  }
}

public protocol AuthenticationMiddleware: Middleware {
  associatedtype AuthType: Authenticatable
  func authType() -> AuthType.Type
}

//Used when auth is not used
public class DummyAuthType: Authenticatable {}

public func routes<dataModel: DataModelApiDelegate, formData: FormDataApiDelegate, headers: HeadersApiDelegate, multipleResponseCodes: MultipleResponseCodesApiDelegate, pathParsing: PathParsingApiDelegate, queryParameters: QueryParametersApiDelegate>
  (_ router: Router, dataModel: dataModel, formData: formData, headers: headers, multipleResponseCodes: multipleResponseCodes, pathParsing: pathParsing, queryParameters: queryParameters)
  throws
  where dataModel.AuthType == DummyAuthType.Type, formData.AuthType == DummyAuthType.Type, headers.AuthType == DummyAuthType.Type, multipleResponseCodes.AuthType == DummyAuthType.Type, pathParsing.AuthType == DummyAuthType.Type, queryParameters.AuthType == DummyAuthType.Type
  {
  //for dataModel
  router.on(.POST, at: SwaggerPath(path: "/schema/referenced/object")) { request -> Future<referencedObjectResponse> in
    return try request.content.decode(SimpleObject.self).flatMap { body in
    return try dataModel.referencedObject(with: request, body: body)
  	}
  }
  //for formData
  router.on(.POST, at: SwaggerPath(path: "/form/request")) { request -> Future<formRequestResponse> in
    let simpleString = try request.content.syncGet(at: "simpleString") as SimpleString
    let simpleNumber = try request.content.syncGet(at: "simpleNumber") as SimpleNumber
    let simpleInteger = try request.content.syncGet(at: "simpleInteger") as SimpleInteger
    let simpleDate = try request.content.syncGet(at: "simpleDate") as SimpleDate
    let simpleEnumString = try request.content.syncGet(at: "simpleEnumString") as SimpleEnumString
    let simpleBoolean = try request.content.syncGet(at: "simpleBoolean") as SimpleBoolean
    let simpleArray = try request.content.syncGet(at: "simpleArray") as [SimpleString]
    return try formData.formRequest(with: request, simpleString: simpleString, simpleNumber: simpleNumber, simpleInteger: simpleInteger, simpleDate: simpleDate, simpleEnumString: simpleEnumString, simpleBoolean: simpleBoolean, simpleArray: simpleArray)
  }
  //for headers
  router.on(.GET, at: SwaggerPath(path: "/headers/in-request")) { request -> Future<requestHeadersResponse> in
    if !request.http.headers.contains(name: "x-example-required-header") {
      throw Abort(.badRequest, reason: "Missing header: x-example-required-header")
    }
    let xExampleRequiredHeader = request.http.headers["x-example-required-header"][0]
    let xExampleArrayHeader = request.http.headers["x-example-array-header"]
    return try headers.requestHeaders(with: request, xExampleRequiredHeader: xExampleRequiredHeader, xExampleArrayHeader: xExampleArrayHeader)
  }
  router.on(.GET, at: SwaggerPath(path: "/headers/in-response")) { request -> Future<responseHeadersResponse> in
    return try headers.responseHeaders(with: request)
  }
  //for multipleResponseCodes
  router.on(.POST, at: SwaggerPath(path: "/multiple/response/codes")) { request -> Future<multipleResponseCodesResponse> in
    return try request.content.decode(MultipleResponseCodeRequest.self).flatMap { body in
    return try multipleResponseCodes.multipleResponseCodes(with: request, body: body)
  	}
  }
  //for pathParsing
  router.on(.GET, at: SwaggerPath(path: "/path/multiple/depth")) { request -> Future<multipleDepthResponse> in
    return try pathParsing.multipleDepth(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path/{param1}/and/{param2}")) { request -> Future<multipleParameterResponse> in
    let param1 = try request.parameters.next(String.self)
    let param2 = try request.parameters.next(String.self)
    return try pathParsing.multipleParameter(with: request, param1: param1, param2: param2)
  }
  router.on(.GET, at: SwaggerPath(path: "/")) { request -> Future<rootPathResponse> in
    return try pathParsing.rootPath(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path-single-depth")) { request -> Future<singleDepthResponse> in
    return try pathParsing.singleDepth(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path/{parameter}")) { request -> Future<singleParameterResponse> in
    let parameter = try request.parameters.next(String.self)
    return try pathParsing.singleParameter(with: request, parameter: parameter)
  }
  //for queryParameters
  router.on(.GET, at: SwaggerPath(path: "/query/parameter")) { request -> Future<queryParametersResponse> in
    let param1 = try request.query.get(String.self, at: "param1")
    let param2 = try? request.query.get(Int.self, at: "param2")
    return try queryParameters.queryParameters(with: request, param1: param1, param2: param2)
  }
}

