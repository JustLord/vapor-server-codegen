import Vapor
import Authentication

// routes.swift
//
// Generated by SwiftVapor3 swagger-codegen
// https://github.com/swagger-api/swagger-codegen
// Template Input: 

private class SwaggerPath: PathComponentsRepresentable {
  private var path: String

  fileprivate init(path: String) {
    self.path = path
  }

  public func convertToPathComponents() -> [PathComponent] {
    return path.split(separator: "/").map {
      if $0.starts(with: "{") && $0.hasSuffix("}") {
        return PathComponent.parameter("string")
      } else {
        return PathComponent.constant(.init($0))
      }
    }
  }
}

public protocol AuthenticationMiddleware: Middleware {
  associatedtype AuthType: Authenticatable
  func authType() -> AuthType.Type
}

//Used when auth is not used
public class DummyAuthType: Authenticatable {}

public func routes<authForSecurity1: AuthenticationMiddleware, authForSecurity2: AuthenticationMiddleware, anotherAuthentication: AnotherAuthenticationApiDelegate, authentication: AuthenticationApiDelegate, dataModel: DataModelApiDelegate, formData: FormDataApiDelegate, headers: HeadersApiDelegate, multipleResponseCodes: MultipleResponseCodesApiDelegate, pathParsing: PathParsingApiDelegate, queryParameters: QueryParametersApiDelegate>
  (_ router: Router, anotherAuthentication: anotherAuthentication, authentication: authentication, dataModel: dataModel, formData: formData, headers: headers, multipleResponseCodes: multipleResponseCodes, pathParsing: pathParsing, queryParameters: queryParameters, authForSecurity1: authForSecurity1, authForSecurity2: authForSecurity2)
  throws
  where authForSecurity1.AuthType == anotherAuthentication.AuthType, authForSecurity1.AuthType == authentication.AuthType, authForSecurity1.AuthType == dataModel.AuthType, authForSecurity1.AuthType == formData.AuthType, authForSecurity1.AuthType == headers.AuthType, authForSecurity1.AuthType == multipleResponseCodes.AuthType, authForSecurity1.AuthType == pathParsing.AuthType, authForSecurity1.AuthType == queryParameters.AuthType, authForSecurity2.AuthType == anotherAuthentication.AuthType, authForSecurity2.AuthType == authentication.AuthType, authForSecurity2.AuthType == dataModel.AuthType, authForSecurity2.AuthType == formData.AuthType, authForSecurity2.AuthType == headers.AuthType, authForSecurity2.AuthType == multipleResponseCodes.AuthType, authForSecurity2.AuthType == pathParsing.AuthType, authForSecurity2.AuthType == queryParameters.AuthType
  {
  let routerForSecurity1 = router.grouped([authForSecurity1])
  let routerForSecurity2 = router.grouped([authForSecurity2])
  //for anotherAuthentication
  routerForSecurity2.on(.GET, at: SwaggerPath(path: "/authentication-another/another")) { request -> Future<anotherApiAnotherSecurityProtectedEndpointResponse> in
    return try anotherAuthentication.anotherApiAnotherSecurityProtectedEndpoint(with: request, asAuthenticated: request.requireAuthenticated(authForSecurity2.authType()))
  }
  routerForSecurity1.on(.GET, at: SwaggerPath(path: "/authentication-another/single")) { request -> Future<anotherApiSecurityProtectedEndpointResponse> in
    return try anotherAuthentication.anotherApiSecurityProtectedEndpoint(with: request, asAuthenticated: request.requireAuthenticated(authForSecurity1.authType()))
  }
  //for authentication
  routerForSecurity2.on(.GET, at: SwaggerPath(path: "/authentication/another")) { request -> Future<anotherSecurityProtectedEndpointResponse> in
    return try authentication.anotherSecurityProtectedEndpoint(with: request, asAuthenticated: request.requireAuthenticated(authForSecurity2.authType()))
  }
  routerForSecurity1.on(.GET, at: SwaggerPath(path: "/authentication/single")) { request -> Future<securityProtectedEndpointResponse> in
    return try authentication.securityProtectedEndpoint(with: request, asAuthenticated: request.requireAuthenticated(authForSecurity1.authType()))
  }
  //for dataModel
  router.on(.POST, at: SwaggerPath(path: "/schema/referenced/object")) { request -> Future<referencedObjectResponse> in
    return try request.content.decode(SimpleObject.self).flatMap { body in
    return try dataModel.referencedObject(with: request, body: body)
  	}
  }
  //for formData
  router.on(.POST, at: SwaggerPath(path: "/form/request")) { request -> Future<formRequestResponse> in
    let simpleString = try request.content.syncGet(at: "simpleString") as SimpleString
    let simpleNumber = try request.content.syncGet(at: "simpleNumber") as SimpleNumber
    let simpleInteger = try request.content.syncGet(at: "simpleInteger") as SimpleInteger
    let simpleDate = try request.content.syncGet(at: "simpleDate") as SimpleDate
    let simpleEnumString = try request.content.syncGet(at: "simpleEnumString") as SimpleEnumString
    let simpleBoolean = try request.content.syncGet(at: "simpleBoolean") as SimpleBoolean
    let simpleArray = try request.content.syncGet(at: "simpleArray") as [SimpleString]
    return try formData.formRequest(with: request, simpleString: simpleString, simpleNumber: simpleNumber, simpleInteger: simpleInteger, simpleDate: simpleDate, simpleEnumString: simpleEnumString, simpleBoolean: simpleBoolean, simpleArray: simpleArray)
  }
  //for headers
  router.on(.GET, at: SwaggerPath(path: "/headers/in-request")) { request -> Future<requestHeadersResponse> in
    if !request.http.headers.contains(name: "x-example-required-header") {
      throw Abort(.badRequest, reason: "Missing header: x-example-required-header")
    }
    let xExampleRequiredHeader = request.http.headers["x-example-required-header"][0]
    let xExampleArrayHeader = request.http.headers["x-example-array-header"]
    return try headers.requestHeaders(with: request, xExampleRequiredHeader: xExampleRequiredHeader, xExampleArrayHeader: xExampleArrayHeader)
  }
  router.on(.GET, at: SwaggerPath(path: "/headers/in-response")) { request -> Future<responseHeadersResponse> in
    return try headers.responseHeaders(with: request)
  }
  //for multipleResponseCodes
  router.on(.POST, at: SwaggerPath(path: "/multiple/response/codes")) { request -> Future<multipleResponseCodesResponse> in
    return try request.content.decode(MultipleResponseCodeRequest.self).flatMap { body in
    return try multipleResponseCodes.multipleResponseCodes(with: request, body: body)
  	}
  }
  //for pathParsing
  router.on(.GET, at: SwaggerPath(path: "/path/multiple/depth")) { request -> Future<multipleDepthResponse> in
    return try pathParsing.multipleDepth(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path/{param1}/and/{param2}")) { request -> Future<multipleParameterResponse> in
    let param1 = try request.parameters.next(String.self)
    let param2 = try request.parameters.next(String.self)
    return try pathParsing.multipleParameter(with: request, param1: param1, param2: param2)
  }
  router.on(.GET, at: SwaggerPath(path: "/")) { request -> Future<rootPathResponse> in
    return try pathParsing.rootPath(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path-single-depth")) { request -> Future<singleDepthResponse> in
    return try pathParsing.singleDepth(with: request)
  }
  router.on(.GET, at: SwaggerPath(path: "/path/{parameter}")) { request -> Future<singleParameterResponse> in
    let parameter = try request.parameters.next(String.self)
    return try pathParsing.singleParameter(with: request, parameter: parameter)
  }
  //for queryParameters
  router.on(.GET, at: SwaggerPath(path: "/query/parameter")) { request -> Future<queryParametersResponse> in
    let param1 = try request.query.get(String.self, at: "param1")
    let param2 = try? request.query.get(Int.self, at: "param2")
    return try queryParameters.queryParameters(with: request, param1: param1, param2: param2)
  }
}

