import Vapor
import RoutingKit

// routes.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: {{importPath}}

extension String {
  var asPathComponents: [PathComponent] {
    return self.split(separator: "/").map {
      if $0.starts(with: "{") && $0.hasSuffix("}") {
        let start = $0.index($0.startIndex, offsetBy: 1)
        let end = $0.index($0.endIndex, offsetBy: -1)
        return PathComponent.parameter(String($0[start..<end]))
      } else {
        return PathComponent.constant(.init($0))
      }
    }
  }
}

public protocol AuthenticationMiddleware: Middleware {
  associatedtype AuthType: Authenticatable
  func authType() -> AuthType.Type
}

//Used when auth is not used
public class DummyAuthType: Authenticatable {}

public func routes<{{#authMethods}}authFor{{{name}}}: AuthenticationMiddleware, {{/authMethods}}{{#apiInfo}}{{#apis}}{{classVarName}}: {{classname}}{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}>
  (_ app: RoutesBuilder{{#apiInfo}}{{#apis}}, {{classVarName}}: {{classVarName}}{{/apis}}{{/apiInfo}}{{#authMethods}}, authFor{{{name}}}: authFor{{{name}}}{{/authMethods}})
  throws
  where {{#hasAuthMethods}}{{#authMethods}}{{#apiInfo}}{{#apis}}authFor{{{name}}}.AuthType == {{classVarName}}.AuthType{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}{{/authMethods}}{{/hasAuthMethods}}{{^hasAuthMethods}}{{#apiInfo}}{{#apis}}{{classVarName}}.AuthType == DummyAuthType.Type{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}{{/hasAuthMethods}}
  {
{{#authMethods}}  let groupFor{{{name}}} = app.grouped([authFor{{{name}}}])
{{/authMethods}}{{#apiInfo}}{{#apis}}
  //for {{classVarName}}
{{#operations}}{{#operation}}{{#contents}}
  {{#authMethods}}groupFor{{{name}}}{{/authMethods}}{{^authMethods}}app{{/authMethods}}.on(.{{httpMethod}}, "{{path}}".asPathComponents) { (request: Request) -> EventLoopFuture<{{operationId}}Response> in
{{#formParams}}    let {{paramName}} = try request.content.get({{dataType}}.self, at: "{{baseName}}")
{{/formParams}}{{#headerParams}}{{^items}}    if !request.headers.contains(name: "{{{baseName}}}") {
      throw Abort(.badRequest, reason: "Missing header: {{{baseName}}}")
    }
{{/items}}    let {{paramName}} = request.headers["{{{baseName}}}"]{{^items}}[0]{{/items}}
{{/headerParams}}{{#queryParams}}    let {{paramName}}{{#required}}Optional{{/required}} = try? request.query.get({{dataType}}.self, at: "{{paramName}}")
{{#required}}
    guard let {{paramName}} = {{paramName}}Optional else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing query parameter {{paramName}}")
    }
{{/required}}{{/queryParams}}{{#pathParams}}    guard let {{paramName}} = request.parameters.get("{{paramName}}", as: {{dataType}}.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter {{paramName}}")
    }
{{/pathParams}}{{#bodyParam}}    let body = try request.content.decode({{dataType}}.self)
  {{/bodyParam}}
    return try {{classVarName}}.{{operationId}}(with: request{{#hasAuthMethods}}{{#authMethods}}, asAuthenticated: request.auth.require(authFor{{{name}}}.authType()){{/authMethods}}{{/hasAuthMethods}}{{#hasParams}}, {{#parameters}}{{paramName}}: {{paramName}}{{#hasMore}}, {{/hasMore}}{{/parameters}}{{/hasParams}})
  }
{{/contents}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}

