import Vapor
import Authentication

// routes.swift
//
// Generated by SwiftVapor3 swagger-codegen
// https://github.com/swagger-api/swagger-codegen
// Template Input: {{importPath}}

private class SwaggerPath: PathComponentsRepresentable {
  private var path: String

  fileprivate init(path: String) {
    self.path = path
  }

  public func convertToPathComponents() -> [PathComponent] {
    return path.split(separator: "/").map {
      if $0.starts(with: "{") && $0.hasSuffix("}") {
        return PathComponent.parameter("string")
      } else {
        return PathComponent.constant(.init($0))
      }
    }
  }
}

public protocol AuthenticationMiddleware: Middleware {
  associatedtype AuthType: Authenticatable
  func authType() -> AuthType.Type
}

//Used when auth is not used
public class DummyAuthType: Authenticatable {}

public func routes<{{#authMethods}}authFor{{{name}}}: AuthenticationMiddleware, {{/authMethods}}{{#apiInfo}}{{#apis}}{{classVarName}}: {{classname}}{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}>
  (_ router: Router{{#apiInfo}}{{#apis}}, {{classVarName}}: {{classVarName}}{{/apis}}{{/apiInfo}}{{#authMethods}}, authFor{{{name}}}: authFor{{{name}}}{{/authMethods}})
  throws
  where {{#hasAuthMethods}}{{#authMethods}}{{#apiInfo}}{{#apis}}authFor{{{name}}}.AuthType == {{classVarName}}.AuthType{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}{{/authMethods}}{{/hasAuthMethods}}{{^hasAuthMethods}}{{#apiInfo}}{{#apis}}{{classVarName}}.AuthType == DummyAuthType.Type{{#hasMore}}, {{/hasMore}}{{/apis}}{{/apiInfo}}{{/hasAuthMethods}}
  {
{{#authMethods}}  let routerFor{{{name}}} = router.grouped([authFor{{{name}}}])
{{/authMethods}}{{#apiInfo}}{{#apis}}
  //for {{classVarName}}
{{#operations}}{{#operation}}{{#contents}}
  {{#authMethods}}routerFor{{{name}}}{{/authMethods}}{{^authMethods}}router{{/authMethods}}.on(.{{httpMethod}}, at: SwaggerPath(path: "{{path}}")) { request -> Future<{{operationId}}Response> in
{{#formParams}}    let {{paramName}} = try request.content.syncGet(at: "{{baseName}}") as {{dataType}}
{{/formParams}}{{#headerParams}}{{^items}}    if !request.http.headers.contains(name: "{{{baseName}}}") {
      throw Abort(.badRequest, reason: "Missing header: {{{baseName}}}")
    }
{{/items}}    let {{paramName}} = request.http.headers["{{{baseName}}}"]{{^items}}[0]{{/items}}
{{/headerParams}}{{#queryParams}}    let {{paramName}} = try{{^required}}?{{/required}} request.query.get({{dataType}}.self, at: "{{paramName}}")
{{/queryParams}}{{#pathParams}}    let {{paramName}} = try request.parameters.next({{dataType}}.self)
{{/pathParams}}{{#bodyParam}}    return try request.content.decode({{dataType}}.self).flatMap { body in
  {{/bodyParam}}
    return try {{classVarName}}.{{operationId}}(with: request{{#hasAuthMethods}}{{#authMethods}}, asAuthenticated: request.requireAuthenticated(authFor{{{name}}}.authType()){{/authMethods}}{{/hasAuthMethods}}{{#hasParams}}, {{#parameters}}{{paramName}}: {{paramName}}{{#hasMore}}, {{/hasMore}}{{/parameters}}{{/hasParams}})
{{#bodyParam}}  	}
{{/bodyParam}}
  }
{{/contents}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}

